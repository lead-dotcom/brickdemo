<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Brick Breaker - Exhibition Demo</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@500;700&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #000;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    overflow: hidden;
    font-family: 'Orbitron', sans-serif;
    touch-action: none;
    user-select: none;
    -webkit-user-select: none;
  }

  #gameContainer {
    position: relative;
    width: 100vmin;
    height: 100vmin;
    max-width: 600px;
    max-height: 600px;
  }

  canvas {
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 12px;
  }

  #overlay {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background: rgba(0,0,10,0.85);
    border-radius: 12px;
    z-index: 10;
    transition: opacity 0.4s;
  }

  #overlay.hidden {
    opacity: 0;
    pointer-events: none;
  }

  #overlay h1 {
    font-family: 'Orbitron', sans-serif;
    font-size: 28px;
    font-weight: 900;
    color: #fff;
    text-shadow: 0 0 20px rgba(255,200,50,0.8), 0 0 40px rgba(255,150,0,0.4);
    margin-bottom: 10px;
    letter-spacing: 3px;
  }

  #overlay .subtitle {
    font-family: 'Rajdhani', sans-serif;
    font-size: 16px;
    color: rgba(255,255,255,0.6);
    margin-bottom: 30px;
    letter-spacing: 1px;
  }

  #startBtn {
    font-family: 'Orbitron', sans-serif;
    font-size: 16px;
    font-weight: 700;
    padding: 14px 40px;
    border: 2px solid rgba(255,200,50,0.6);
    background: linear-gradient(180deg, rgba(255,200,50,0.2), rgba(255,150,0,0.1));
    color: #ffd040;
    border-radius: 50px;
    cursor: pointer;
    letter-spacing: 2px;
    transition: all 0.3s;
    text-transform: uppercase;
  }

  #startBtn:hover {
    background: linear-gradient(180deg, rgba(255,200,50,0.4), rgba(255,150,0,0.2));
    box-shadow: 0 0 30px rgba(255,200,50,0.3);
    transform: scale(1.05);
  }

  #hud {
    position: absolute;
    top: 8px;
    left: 16px;
    right: 16px;
    display: flex;
    justify-content: space-between;
    z-index: 5;
    font-family: 'Rajdhani', sans-serif;
    font-size: 14px;
    font-weight: 700;
    color: rgba(255,255,255,0.7);
    letter-spacing: 1px;
  }

  #resultMsg {
    font-family: 'Orbitron', sans-serif;
    font-size: 20px;
    font-weight: 700;
    color: #ffd040;
    margin-bottom: 20px;
    text-shadow: 0 0 15px rgba(255,200,50,0.6);
  }
</style>
</head>
<body>

<div id="gameContainer">
  <canvas id="gameCanvas"></canvas>
  <div id="hud">
    <span id="scoreDisplay">SCORE: 0</span>
    <span id="gameTitle">it's a sweet thinking game</span>
    <span id="livesDisplay">â™¥ â™¥ â™¥</span>
  </div>
  <div id="overlay">
    <h1>BRICK BREAKER</h1>
    <div class="subtitle">Exhibition Demo</div>
    <div id="resultMsg"></div>
    <button id="startBtn">START</button>
  </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');
const startBtn = document.getElementById('startBtn');
const scoreDisplay = document.getElementById('scoreDisplay');
const livesDisplay = document.getElementById('livesDisplay');
const resultMsg = document.getElementById('resultMsg');

// High-DPI
const SCALE = 2;
const W = 600;
const H = 600;
canvas.width = W * SCALE;
canvas.height = H * SCALE;
ctx.scale(SCALE, SCALE);

// Game state
let gameRunning = false;
let score = 0;
let lives = 3;
let animFrame;

// Colors matching the image
const BRICK_COLORS = [
  { main: '#e63946', glow: 'rgba(230,57,70,0.6)' },   // Red
  { main: '#f4a423', glow: 'rgba(244,164,35,0.6)' },   // Yellow/Orange
  { main: '#2dc653', glow: 'rgba(45,198,83,0.6)' },     // Green
  { main: '#2196f3', glow: 'rgba(33,150,243,0.6)' },    // Blue
];

const SPECIAL_WORDS = ['Move', 'Secret', 'Moment'];

// Paddle
const paddle = {
  w: 120, h: 16, x: 0, y: 0, speed: 8, targetX: 0,
  reset() {
    this.x = W / 2 - this.w / 2;
    this.y = H - 55;
    this.targetX = this.x;
  }
};

// Ball
const ball = {
  x: 0, y: 0, r: 7, dx: 0, dy: 0, speed: 4.5, trail: [],
  reset() {
    this.x = W / 2;
    this.y = paddle.y - 20;
    const angle = -Math.PI / 2 + (Math.random() - 0.5) * 0.6;
    this.dx = Math.cos(angle) * this.speed;
    this.dy = Math.sin(angle) * this.speed;
    this.trail = [];
  }
};

// Bricks
let bricks = [];
const COLS = 6;
const ROWS = 4;
const BRICK_W = 72;
const BRICK_H = 42;
const BRICK_PAD = 10;
const BRICK_OFFSET_X = (W - (COLS * (BRICK_W + BRICK_PAD) - BRICK_PAD)) / 2;
const BRICK_OFFSET_Y = 50;

// Particles
let particles = [];

// Stars background
let stars = [];
for (let i = 0; i < 120; i++) {
  stars.push({
    x: Math.random() * W,
    y: Math.random() * H,
    r: Math.random() * 1.5 + 0.3,
    alpha: Math.random() * 0.7 + 0.3,
    twinkle: Math.random() * 0.02 + 0.005
  });
}

function createBricks() {
  bricks = [];
  let specialIndices = [];
  // Place special words at specific positions like the image
  // Row 0 col 0 = "Move", Row 1 col 3 = "Secret", Row 3 col 5 = "Moment"
  const specials = [
    { r: 0, c: 0, word: 'Move' },
    { r: 1, c: 3, word: 'Secret' },
    { r: 3, c: 5, word: 'Moment' },
  ];

  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const color = BRICK_COLORS[(r + c) % BRICK_COLORS.length];
      const special = specials.find(s => s.r === r && s.c === c);
      bricks.push({
        x: BRICK_OFFSET_X + c * (BRICK_W + BRICK_PAD),
        y: BRICK_OFFSET_Y + r * (BRICK_H + BRICK_PAD),
        w: BRICK_W,
        h: BRICK_H,
        color: color,
        alive: true,
        word: special ? special.word : null,
        hp: special ? 2 : 1,
        shake: 0,
        glowPulse: Math.random() * Math.PI * 2
      });
    }
  }
}

function spawnParticles(x, y, color, count = 12) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = Math.random() * 4 + 1.5;
    const size = Math.random() * 6 + 3;
    particles.push({
      x, y,
      dx: Math.cos(angle) * speed,
      dy: Math.sin(angle) * speed - 1,
      size,
      color,
      alpha: 1,
      rotation: Math.random() * Math.PI * 2,
      rotSpeed: (Math.random() - 0.5) * 0.2,
      life: 1,
      decay: Math.random() * 0.015 + 0.01
    });
  }
}

// Drawing functions
function drawBackground() {
  // Space gradient
  const grad = ctx.createRadialGradient(W/2, H/2, 50, W/2, H/2, W);
  grad.addColorStop(0, '#0a0a2e');
  grad.addColorStop(0.5, '#050520');
  grad.addColorStop(1, '#000008');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Stars
  const time = Date.now() * 0.001;
  stars.forEach(s => {
    const a = s.alpha + Math.sin(time * s.twinkle * 100) * 0.2;
    ctx.fillStyle = `rgba(255,255,255,${Math.max(0, Math.min(1, a))})`;
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
    ctx.fill();
  });
}

function drawBrick(b) {
  if (!b.alive) return;

  const time = Date.now() * 0.003;
  b.glowPulse += 0.02;

  const ox = b.shake > 0 ? (Math.random() - 0.5) * b.shake : 0;
  const oy = b.shake > 0 ? (Math.random() - 0.5) * b.shake : 0;
  if (b.shake > 0) b.shake *= 0.85;

  const bx = b.x + ox;
  const by = b.y + oy;

  // Outer glow
  const glowSize = 8 + Math.sin(b.glowPulse) * 2;
  ctx.shadowColor = b.color.glow;
  ctx.shadowBlur = glowSize;

  // Brick body
  const radius = 6;
  ctx.beginPath();
  ctx.roundRect(bx, by, b.w, b.h, radius);

  // Gradient fill
  const grad = ctx.createLinearGradient(bx, by, bx, by + b.h);
  grad.addColorStop(0, lightenColor(b.color.main, 30));
  grad.addColorStop(0.5, b.color.main);
  grad.addColorStop(1, darkenColor(b.color.main, 20));
  ctx.fillStyle = grad;
  ctx.fill();

  // Inner highlight
  ctx.beginPath();
  ctx.roundRect(bx + 3, by + 3, b.w - 6, b.h / 2 - 3, [4, 4, 0, 0]);
  ctx.fillStyle = 'rgba(255,255,255,0.15)';
  ctx.fill();

  ctx.shadowBlur = 0;

  // Word text
  if (b.word) {
    ctx.font = '700 15px "Rajdhani", sans-serif';
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(b.word, bx + b.w / 2, by + b.h / 2 + 1);
  }
}

function drawPaddle() {
  const px = paddle.x;
  const py = paddle.y;

  // Paddle glow
  ctx.shadowColor = 'rgba(255,200,50,0.5)';
  ctx.shadowBlur = 15;

  // Main paddle body - golden metallic
  const grad = ctx.createLinearGradient(px, py, px, py + paddle.h);
  grad.addColorStop(0, '#ffd866');
  grad.addColorStop(0.3, '#f0c040');
  grad.addColorStop(0.5, '#daa520');
  grad.addColorStop(0.7, '#b8860b');
  grad.addColorStop(1, '#8b6914');

  ctx.beginPath();
  ctx.roundRect(px, py, paddle.w, paddle.h, paddle.h / 2);
  ctx.fillStyle = grad;
  ctx.fill();

  // Highlight stripe
  ctx.beginPath();
  ctx.roundRect(px + 15, py + 3, paddle.w - 30, 5, 3);
  ctx.fillStyle = 'rgba(255,240,180,0.5)';
  ctx.fill();

  // Edge caps
  const capGrad = ctx.createRadialGradient(px + 8, py + paddle.h/2, 2, px + 8, py + paddle.h/2, 8);
  capGrad.addColorStop(0, '#ffe080');
  capGrad.addColorStop(1, '#b8860b');
  ctx.beginPath();
  ctx.arc(px + 8, py + paddle.h/2, 6, 0, Math.PI * 2);
  ctx.fillStyle = capGrad;
  ctx.fill();

  const capGrad2 = ctx.createRadialGradient(px + paddle.w - 8, py + paddle.h/2, 2, px + paddle.w - 8, py + paddle.h/2, 8);
  capGrad2.addColorStop(0, '#ffe080');
  capGrad2.addColorStop(1, '#b8860b');
  ctx.beginPath();
  ctx.arc(px + paddle.w - 8, py + paddle.h/2, 6, 0, Math.PI * 2);
  ctx.fillStyle = capGrad2;
  ctx.fill();

  ctx.shadowBlur = 0;
}

function drawBall() {
  // Trail
  ball.trail.push({ x: ball.x, y: ball.y });
  if (ball.trail.length > 12) ball.trail.shift();

  ball.trail.forEach((p, i) => {
    const alpha = (i / ball.trail.length) * 0.4;
    const r = ball.r * (i / ball.trail.length) * 0.8;
    ctx.beginPath();
    ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(255,200,50,${alpha})`;
    ctx.fill();
  });

  // Ball glow
  ctx.shadowColor = 'rgba(255,200,50,0.8)';
  ctx.shadowBlur = 15;

  // Ball body
  const grad = ctx.createRadialGradient(ball.x - 2, ball.y - 2, 1, ball.x, ball.y, ball.r);
  grad.addColorStop(0, '#fff8e0');
  grad.addColorStop(0.4, '#ffd040');
  grad.addColorStop(1, '#d4900a');
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
  ctx.fillStyle = grad;
  ctx.fill();

  ctx.shadowBlur = 0;
}

function drawParticles() {
  particles.forEach(p => {
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.rotate(p.rotation);
    ctx.globalAlpha = p.alpha * p.life;
    ctx.fillStyle = p.color;
    ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
    ctx.restore();
  });
  ctx.globalAlpha = 1;
}

function updateParticles() {
  particles = particles.filter(p => {
    p.x += p.dx;
    p.y += p.dy;
    p.dy += 0.08; // gravity
    p.rotation += p.rotSpeed;
    p.life -= p.decay;
    p.alpha = p.life;
    return p.life > 0;
  });
}

// Collision
function ballBrickCollision(b) {
  if (!b.alive) return false;

  const bx = ball.x, by = ball.y, br = ball.r;
  const closestX = Math.max(b.x, Math.min(bx, b.x + b.w));
  const closestY = Math.max(b.y, Math.min(by, b.y + b.h));
  const dx = bx - closestX;
  const dy = by - closestY;

  if (dx * dx + dy * dy < br * br) {
    b.hp--;
    if (b.hp <= 0) {
      b.alive = false;
      score += b.word ? 50 : 10;
      spawnParticles(b.x + b.w/2, b.y + b.h/2, b.color.main, b.word ? 20 : 12);
    } else {
      b.shake = 6;
      spawnParticles(closestX, closestY, b.color.main, 5);
    }

    // Determine bounce direction
    const overlapX = br - Math.abs(dx);
    const overlapY = br - Math.abs(dy);
    if (overlapX < overlapY) {
      ball.dx = -ball.dx;
    } else {
      ball.dy = -ball.dy;
    }
    return true;
  }
  return false;
}

function update() {
  // Smooth paddle movement
  const diff = paddle.targetX - paddle.x;
  paddle.x += diff * 0.15;

  // Ball movement
  ball.x += ball.dx;
  ball.y += ball.dy;

  // Wall collisions
  if (ball.x - ball.r <= 0) { ball.x = ball.r; ball.dx = Math.abs(ball.dx); }
  if (ball.x + ball.r >= W) { ball.x = W - ball.r; ball.dx = -Math.abs(ball.dx); }
  if (ball.y - ball.r <= 0) { ball.y = ball.r; ball.dy = Math.abs(ball.dy); }

  // Bottom - lose life
  if (ball.y + ball.r > H) {
    lives--;
    updateLivesDisplay();
    if (lives <= 0) {
      endGame(false);
      return;
    }
    ball.reset();
  }

  // Paddle collision
  if (ball.dy > 0 &&
      ball.y + ball.r >= paddle.y &&
      ball.y + ball.r <= paddle.y + paddle.h + 5 &&
      ball.x >= paddle.x - 5 &&
      ball.x <= paddle.x + paddle.w + 5) {
    const hitPos = (ball.x - paddle.x) / paddle.w; // 0 to 1
    const angle = (hitPos - 0.5) * Math.PI * 0.7 - Math.PI / 2;
    const currentSpeed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
    ball.dx = Math.cos(angle) * currentSpeed;
    ball.dy = Math.sin(angle) * currentSpeed;
    if (ball.dy > -1) ball.dy = -1; // ensure upward
    ball.y = paddle.y - ball.r;
    spawnParticles(ball.x, paddle.y, '#ffd040', 4);
  }

  // Brick collisions
  let allDead = true;
  for (const b of bricks) {
    if (b.alive) allDead = false;
    ballBrickCollision(b);
  }

  if (allDead) {
    endGame(true);
    return;
  }

  updateParticles();
  scoreDisplay.textContent = `SCORE: ${score}`;
}

function draw() {
  drawBackground();
  bricks.forEach(drawBrick);
  drawParticles();
  drawPaddle();
  drawBall();
}

function gameLoop() {
  if (!gameRunning) return;
  update();
  draw();
  animFrame = requestAnimationFrame(gameLoop);
}

function startGame() {
  score = 0;
  lives = 3;
  particles = [];
  paddle.reset();
  ball.reset();
  createBricks();
  updateLivesDisplay();
  scoreDisplay.textContent = 'SCORE: 0';
  overlay.classList.add('hidden');
  gameRunning = true;
  gameLoop();
}

function endGame(won) {
  gameRunning = false;
  cancelAnimationFrame(animFrame);
  resultMsg.textContent = won ? 'ðŸŽ‰ CLEAR!' : `GAME OVER â€” SCORE: ${score}`;
  startBtn.textContent = 'RETRY';
  overlay.classList.remove('hidden');
}

function updateLivesDisplay() {
  livesDisplay.textContent = 'â™¥ '.repeat(lives).trim() + ' â™¡ '.repeat(Math.max(0, 3 - lives)).trim();
}

// Input handlers
const container = document.getElementById('gameContainer');

function getPointerX(e) {
  const rect = canvas.getBoundingClientRect();
  const clientX = e.touches ? e.touches[0].clientX : e.clientX;
  return (clientX - rect.left) / rect.width * W;
}

container.addEventListener('mousemove', (e) => {
  if (!gameRunning) return;
  paddle.targetX = Math.max(0, Math.min(W - paddle.w, getPointerX(e) - paddle.w / 2));
});

container.addEventListener('touchmove', (e) => {
  e.preventDefault();
  if (!gameRunning) return;
  paddle.targetX = Math.max(0, Math.min(W - paddle.w, getPointerX(e) - paddle.w / 2));
}, { passive: false });

container.addEventListener('touchstart', (e) => {
  if (!gameRunning) return;
  paddle.targetX = Math.max(0, Math.min(W - paddle.w, getPointerX(e) - paddle.w / 2));
}, { passive: false });

// Keyboard
document.addEventListener('keydown', (e) => {
  if (!gameRunning) return;
  if (e.key === 'ArrowLeft') paddle.targetX = Math.max(0, paddle.targetX - 30);
  if (e.key === 'ArrowRight') paddle.targetX = Math.min(W - paddle.w, paddle.targetX + 30);
});

startBtn.addEventListener('click', startGame);

// Helper color functions
function lightenColor(hex, amt) {
  const num = parseInt(hex.slice(1), 16);
  const r = Math.min(255, (num >> 16) + amt);
  const g = Math.min(255, ((num >> 8) & 0xff) + amt);
  const b = Math.min(255, (num & 0xff) + amt);
  return `rgb(${r},${g},${b})`;
}

function darkenColor(hex, amt) {
  const num = parseInt(hex.slice(1), 16);
  const r = Math.max(0, (num >> 16) - amt);
  const g = Math.max(0, ((num >> 8) & 0xff) - amt);
  const b = Math.max(0, (num & 0xff) - amt);
  return `rgb(${r},${g},${b})`;
}

// Draw initial state
drawBackground();
</script>
</body>
</html>
